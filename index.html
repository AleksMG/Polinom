<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>üî¢ –®–∏—Ñ—Ä–∞—Ç–æ—Ä (1 —Å–∏–º–≤–æ–ª = 5 —Ü–∏—Ñ—Ä) | AES</title>
    <style>
        body { font-family: Arial; max-width: 800px; margin: 0 auto; padding: 20px; }
        textarea, input, button { width: 100%; margin: 10px 0; padding: 10px; }
        button { background: #4CAF50; color: white; border: none; cursor: pointer; }
        .result { background: #f4f4f4; padding: 15px; margin-top: 10px; word-break: break-all; }
    </style>
</head>
<body>
    <h1>üî¢ –®–∏—Ñ—Ä–∞—Ç–æ—Ä (1 —Å–∏–º–≤–æ–ª = 5 —Ü–∏—Ñ—Ä)</h1>
    <p><strong>–ê–ª–≥–æ—Ä–∏—Ç–º: AES (Web Crypto API)</strong></p>
    
    <div>
        <h2>üîí –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ</h2>
        <input type="password" id="key" placeholder="–ö–ª—é—á (–ª—é–±–∞—è —Å—Ç—Ä–æ–∫–∞)">
        <textarea id="text" placeholder="–¢–µ–∫—Å—Ç –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è"></textarea>
        <button onclick="encrypt()">–ó–∞—à–∏—Ñ—Ä–æ–≤–∞—Ç—å ‚Üí –ß–∏—Å–ª–∞</button>
        <div class="result" id="encoded"></div>
    </div>
    
    <div>
        <h2>üîì –î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ</h2>
        <input type="password" id="decode-key" placeholder="–ö–ª—é—á (–¥–æ–ª–∂–µ–Ω —Å–æ–≤–ø–∞–¥–∞—Ç—å)">
        <textarea id="numbers" placeholder="–ß–∏—Å–ª–∞ –¥–ª—è –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è (—á–µ—Ä–µ–∑ –ø—Ä–æ–±–µ–ª)"></textarea>
        <button onclick="decrypt()">–î–µ—à–∏—Ñ—Ä–æ–≤–∞—Ç—å ‚Üí –¢–µ–∫—Å—Ç</button>
        <div class="result" id="decoded"></div>
    </div>

    <script>
        // –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –±–∞–π—Ç–æ–≤ –≤ 5-–∑–Ω–∞—á–Ω—ã–µ —á–∏—Å–ª–∞ (–±–µ–∑ –ø–æ—Ç–µ—Ä—å)
        function bytesToNumbers(bytes) {
            const numbers = [];
            for (let i = 0; i < bytes.length; i += 2) {
                // –ë–µ—Ä–µ–º 2 –±–∞–π—Ç–∞ = 65535 –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ (–≤–º–µ—â–∞–µ—Ç—Å—è –≤ 5 —Ü–∏—Ñ—Ä)
                const byte1 = bytes[i];
                const byte2 = i + 1 < bytes.length ? bytes[i + 1] : 0;
                const num = (byte1 << 8) | byte2; // –û–±—ä–µ–¥–∏–Ω—è–µ–º –≤ 16-–±–∏—Ç–Ω–æ–µ —á–∏—Å–ª–æ
                numbers.push(num.toString().padStart(5, '0')); // 5 —Ü–∏—Ñ—Ä
            }
            return numbers;
        }

        // –û–±—Ä–∞—Ç–Ω–∞—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è (–∏–∑ —á–∏—Å–µ–ª –≤ –±–∞–π—Ç—ã)
        function numbersToBytes(numbers) {
            const bytes = new Uint8Array(numbers.length * 2);
            for (let i = 0; i < numbers.length; i++) {
                const num = parseInt(numbers[i], 10);
                bytes[i * 2] = (num >> 8) & 0xFF; // –°—Ç–∞—Ä—à–∏–π –±–∞–π—Ç
                bytes[i * 2 + 1] = num & 0xFF;    // –ú–ª–∞–¥—à–∏–π –±–∞–π—Ç
            }
            return bytes;
        }

        // –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ AES (Web Crypto API)
        async function encryptAES(text, keyStr) {
            const key = await crypto.subtle.importKey(
                'raw',
                new TextEncoder().encode(keyStr),
                { name: 'AES-CBC', length: 256 },
                false,
                ['encrypt']
            );
            const iv = crypto.getRandomValues(new Uint8Array(16));
            const encrypted = await crypto.subtle.encrypt(
                { name: 'AES-CBC', iv },
                key,
                new TextEncoder().encode(text)
            );
            // –û–±—ä–µ–¥–∏–Ω—è–µ–º IV + –¥–∞–Ω–Ω—ã–µ –¥–ª—è –ø–µ—Ä–µ–¥–∞—á–∏
            const result = new Uint8Array(iv.length + encrypted.byteLength);
            result.set(iv, 0);
            result.set(new Uint8Array(encrypted), iv.length);
            return result;
        }

        // –î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ AES (Web Crypto API)
        async function decryptAES(data, keyStr) {
            const key = await crypto.subtle.importKey(
                'raw',
                new TextEncoder().encode(keyStr),
                { name: 'AES-CBC', length: 256 },
                false,
                ['decrypt']
            );
            const iv = data.slice(0, 16);
            const encrypted = data.slice(16);
            const decrypted = await crypto.subtle.decrypt(
                { name: 'AES-CBC', iv },
                key,
                encrypted
            );
            return new TextDecoder().decode(decrypted);
        }

        // –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞ ‚Üí —á–∏—Å–ª–∞
        async function encrypt() {
            const text = document.getElementById('text').value;
            const key = document.getElementById('key').value;
            if (!text || !key) return alert("–ù—É–∂–µ–Ω —Ç–µ–∫—Å—Ç –∏ –∫–ª—é—á!");

            try {
                const encryptedBytes = await encryptAES(text, key);
                const numbers = bytesToNumbers(encryptedBytes);
                document.getElementById('encoded').textContent = numbers.join(' ');
                document.getElementById('numbers').value = numbers.join(' ');
            } catch (e) {
                alert("–û—à–∏–±–∫–∞ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è: " + e.message);
            }
        }

        // –î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ —á–∏—Å–µ–ª ‚Üí —Ç–µ–∫—Å—Ç
        async function decrypt() {
            const numbers = document.getElementById('numbers').value.trim().split(/\s+/);
            const key = document.getElementById('decode-key').value;
            if (!numbers.length || !key) return alert("–ù—É–∂–Ω—ã —á–∏—Å–ª–∞ –∏ –∫–ª—é—á!");

            try {
                const bytes = numbersToBytes(numbers);
                const decrypted = await decryptAES(bytes, key);
                document.getElementById('decoded').textContent = decrypted;
            } catch (e) {
                alert("–û—à–∏–±–∫–∞ –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è: –Ω–µ–≤–µ—Ä–Ω—ã–π –∫–ª—é—á –∏–ª–∏ –¥–∞–Ω–Ω—ã–µ");
            }
        }
    </script>
</body>
</html>
