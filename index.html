<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ADFGVX Шифратор (KRYPTOS-совместимый)</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background-color: #0f0f23;
            color: #00ff00;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
        }
        h1 {
            color: #ffff00;
            text-align: center;
            border-bottom: 1px solid #333;
            padding-bottom: 10px;
        }
        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        .panel {
            flex: 1;
            min-width: 300px;
            background: #1a1a2a;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #333;
        }
        table {
            border-collapse: collapse;
            margin: 10px 0;
            width: 100%;
        }
        th, td {
            border: 1px solid #444;
            padding: 5px;
            text-align: center;
        }
        th {
            background-color: #2a2a3a;
        }
        input[type="text"] {
            background: #0a0a1a;
            border: 1px solid #333;
            color: #00ff00;
            padding: 5px;
            width: 100%;
            font-family: 'Courier New', monospace;
        }
        button {
            background: #2a2a3a;
            color: #00ff00;
            border: 1px solid #333;
            padding: 8px 15px;
            margin: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
        }
        button:hover {
            background: #3a3a4a;
        }
        textarea {
            width: 100%;
            min-height: 100px;
            background: #0a0a1a;
            border: 1px solid #333;
            color: #00ff00;
            padding: 10px;
            font-family: 'Courier New', monospace;
            margin-bottom: 10px;
        }
        .error {
            color: #ff5555;
        }
        .success {
            color: #55ff55;
        }
        .warning {
            color: #ffaa00;
        }
        .debug {
            font-size: 0.9em;
            color: #aaa;
        }
    </style>
</head>
<body>
    <h1>ADFGVX Шифратор (KRYPTOS-совместимый)</h1>
    
    <div class="container">
        <div class="panel">
            <h2>Конфигурация</h2>
            
            <table id="substitution-grid">
                <tr>
                    <th></th>
                    <th>A</th>
                    <th>D</th>
                    <th>F</th>
                    <th>G</th>
                    <th>V</th>
                    <th>X</th>
                </tr>
                <!-- Заполнится JavaScript -->
            </table>
            
            <div>
                <label for="transposition-key">Ключ перестановки:</label>
                <input type="text" id="transposition-key" value="KRYPTOS">
            </div>
            
            <button id="encrypt-btn">Зашифровать</button>
            <button id="decrypt-btn">Расшифровать</button>
            <button id="reset-btn">Сбросить</button>
        </div>
        
        <div class="panel">
            <h2>Обработка сообщения</h2>
            
            <textarea id="input-text" placeholder="Введите текст...">HELLO</textarea>
            
            <h3>Результат:</h3>
            <textarea id="output-text" readonly></textarea>
            
            <div id="status" class="success">Готов</div>
            
            <h3>Отладка</h3>
            <div id="debug" class="debug"></div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Стандартная таблица подстановки ADFGVX
            const defaultGrid = [
                ['A', 'B', 'C', 'D', 'E', 'F'],
                ['G', 'H', 'I', 'J', 'K', 'L'],
                ['M', 'N', 'O', 'P', 'Q', 'R'],
                ['S', 'T', 'U', 'V', 'W', 'X'],
                ['Y', 'Z', '0', '1', '2', '3'],
                ['4', '5', '6', '7', '8', '9']
            ];
            
            let currentGrid = JSON.parse(JSON.stringify(defaultGrid));
            const gridTable = document.getElementById('substitution-grid');
            
            // Инициализация таблицы подстановки
            function renderGrid() {
                // Очищаем таблицу (кроме заголовка)
                while (gridTable.rows.length > 1) {
                    gridTable.deleteRow(1);
                }
                
                const rowLabels = ['A', 'D', 'F', 'G', 'V', 'X'];
                for (let i = 0; i < 6; i++) {
                    const row = gridTable.insertRow();
                    const headerCell = row.insertCell();
                    headerCell.textContent = rowLabels[i];
                    headerCell.style.fontWeight = 'bold';
                    
                    for (let j = 0; j < 6; j++) {
                        const cell = row.insertCell();
                        const input = document.createElement('input');
                        input.type = 'text';
                        input.maxLength = 1;
                        input.value = currentGrid[i][j];
                        input.dataset.row = i;
                        input.dataset.col = j;
                        input.addEventListener('change', function() {
                            currentGrid[this.dataset.row][this.dataset.col] = this.value.toUpperCase();
                        });
                        cell.appendChild(input);
                    }
                }
            }
            
            // Создаем карту "символ → код ADFGVX"
            function getCharToCodeMap() {
                const map = {};
                const rowLabels = ['A', 'D', 'F', 'G', 'V', 'X'];
                const colLabels = ['A', 'D', 'F', 'G', 'V', 'X'];
                
                for (let i = 0; i < 6; i++) {
                    for (let j = 0; j < 6; j++) {
                        const char = currentGrid[i][j];
                        if (char) {
                            map[char.toUpperCase()] = rowLabels[i] + colLabels[j];
                        }
                    }
                }
                return map;
            }
            
            // Создаем карту "код ADFGVX → символ"
            function getCodeToCharMap() {
                const map = {};
                const rowLabels = ['A', 'D', 'F', 'G', 'V', 'X'];
                const colLabels = ['A', 'D', 'F', 'G', 'V', 'X'];
                
                for (let i = 0; i < 6; i++) {
                    for (let j = 0; j < 6; j++) {
                        const char = currentGrid[i][j];
                        if (char) {
                            map[rowLabels[i] + colLabels[j]] = char.toUpperCase();
                        }
                    }
                }
                return map;
            }
            
            // Шифрование
            function encrypt() {
                const plaintext = document.getElementById('input-text').value.toUpperCase().replace(/[^A-Z0-9]/g, '');
                const key = document.getElementById('transposition-key').value.toUpperCase().replace(/[^A-Z]/g, '');
                
                if (!plaintext) {
                    updateStatus('Ошибка: Нет текста для шифрования', 'error');
                    return;
                }
                
                if (!key) {
                    updateStatus('Ошибка: Введите ключ перестановки', 'error');
                    return;
                }
                
                try {
                    // Этап 1: Подстановка
                    const charToCode = getCharToCodeMap();
                    let substituted = '';
                    let debugInfo = "<strong>Этап 1: Подстановка</strong><br>";
                    
                    for (const char of plaintext) {
                        if (charToCode[char]) {
                            substituted += charToCode[char];
                            debugInfo += `${char} → ${charToCode[char]}<br>`;
                        } else {
                            updateStatus(`Ошибка: Символ '${char}' отсутствует в таблице`, 'error');
                            return;
                        }
                    }
                    
                    debugInfo += `<strong>Результат подстановки:</strong> ${substituted}<br><br>`;
                    
                    // Этап 2: Перестановка
                    const numCols = key.length;
                    const numRows = Math.ceil(substituted.length / numCols);
                    const padding = numCols * numRows - substituted.length;
                    
                    // Заполняем матрицу по строкам
                    const matrix = [];
                    for (let i = 0; i < numRows; i++) {
                        const start = i * numCols;
                        const end = start + numCols;
                        matrix.push(substituted.slice(start, end).split(''));
                    }
                    
                    // Добавляем padding при необходимости
                    if (padding > 0) {
                        for (let i = 0; i < padding; i++) {
                            matrix[numRows-1].push(' ');
                        }
                    }
                    
                    debugInfo += `<strong>Этап 2: Перестановка</strong><br>`;
                    debugInfo += `Ключ: ${key}<br>`;
                    debugInfo += `Длина ключа: ${numCols} столбцов<br>`;
                    debugInfo += `Количество строк: ${numRows}<br>`;
                    debugInfo += `Дополнение: ${padding} символов<br><br>`;
                    
                    // Сортируем столбцы по ключу
                    const keyChars = key.split('');
                    const keyOrder = keyChars
                        .map((char, index) => ({ char, index }))
                        .sort((a, b) => a.char.localeCompare(b.char))
                        .map(item => item.index);
                    
                    debugInfo += `<strong>Порядок столбцов:</strong><br>`;
                    debugInfo += `Исходный: ${keyChars.join(' ')}<br>`;
                    debugInfo += `Сортированный: ${keyOrder.map(i => keyChars[i]).join(' ')}<br>`;
                    debugInfo += `Индексы: ${keyOrder.join(' ')}<br><br>`;
                    
                    // Читаем шифртекст по новым столбцам
                    let ciphertext = '';
                    for (const col of keyOrder) {
                        for (let row = 0; row < numRows; row++) {
                            if (matrix[row][col] && matrix[row][col] !== ' ') {
                                ciphertext += matrix[row][col];
                            }
                        }
                    }
                    
                    document.getElementById('output-text').value = ciphertext;
                    updateStatus('Шифрование успешно', 'success');
                    
                    // Отображаем отладочную информацию
                    debugInfo += `<strong>Матрица перестановки:</strong><br>`;
                    debugInfo += `<table border="1" style="border-collapse: collapse; margin: 5px 0;">`;
                    debugInfo += `<tr><th>Исх.\\Сорт.</th>${keyOrder.map(i => `<th>${keyChars[i]}</th>`).join('')}</tr>`;
                    
                    for (let row = 0; row < numRows; row++) {
                        debugInfo += `<tr><td>${row+1}</td>`;
                        for (const col of keyOrder) {
                            debugInfo += `<td>${matrix[row][col] || ' '}</td>`;
                        }
                        debugInfo += `</tr>`;
                    }
                    
                    debugInfo += `</table><br>`;
                    debugInfo += `<strong>Итоговый шифртекст:</strong> ${ciphertext}`;
                    
                    document.getElementById('debug').innerHTML = debugInfo;
                    
                } catch (error) {
                    updateStatus(`Ошибка: ${error.message}`, 'error');
                }
            }
            
            // Расшифрование
            function decrypt() {
                const ciphertext = document.getElementById('input-text').value.toUpperCase().replace(/[^ADFGVX]/g, '');
                const key = document.getElementById('transposition-key').value.toUpperCase().replace(/[^A-Z]/g, '');
                
                if (!ciphertext) {
                    updateStatus('Ошибка: Нет текста для расшифрования', 'error');
                    return;
                }
                
                if (!key) {
                    updateStatus('Ошибка: Введите ключ перестановки', 'error');
                    return;
                }
                
                if (ciphertext.length % 2 !== 0) {
                    updateStatus('Ошибка: Длина шифртекста должна быть четной', 'error');
                    return;
                }
                
                try {
                    // Этап 1: Обратная перестановка
                    const numCols = key.length;
                    const numRows = Math.ceil(ciphertext.length / numCols);
                    const padding = numCols * numRows - ciphertext.length;
                    
                    const keyChars = key.split('');
                    const keyOrder = keyChars
                        .map((char, index) => ({ char, index }))
                        .sort((a, b) => a.char.localeCompare(b.char))
                        .map(item => item.index);
                    
                    // Восстанавливаем порядок столбцов
                    const colMap = {};
                    keyOrder.forEach((originalCol, sortedCol) => {
                        colMap[sortedCol] = originalCol;
                    });
                    
                    // Создаем матрицу для расшифровки
                    const matrix = new Array(numRows);
                    for (let i = 0; i < numRows; i++) {
                        matrix[i] = new Array(numCols).fill('');
                    }
                    
                    // Заполняем матрицу по отсортированным столбцам
                    let index = 0;
                    for (let sortedCol = 0; sortedCol < numCols; sortedCol++) {
                        const originalCol = colMap[sortedCol];
                        const charsInCol = (originalCol >= numCols - padding) ? numRows - 1 : numRows;
                        
                        for (let row = 0; row < charsInCol; row++) {
                            if (index < ciphertext.length) {
                                matrix[row][originalCol] = ciphertext[index++];
                            }
                        }
                    }
                    
                    // Читаем по строкам
                    let substituted = '';
                    for (let row = 0; row < numRows; row++) {
                        for (let col = 0; col < numCols; col++) {
                            if (matrix[row][col]) {
                                substituted += matrix[row][col];
                            }
                        }
                    }
                    
                    // Этап 2: Обратная подстановка
                    const codeToChar = getCodeToCharMap();
                    let plaintext = '';
                    
                    for (let i = 0; i < substituted.length; i += 2) {
                        const code = substituted.substr(i, 2);
                        if (codeToChar[code]) {
                            plaintext += codeToChar[code];
                        } else {
                            plaintext += '?';
                            updateStatus(`Предупреждение: Код '${code}' не найден`, 'warning');
                        }
                    }
                    
                    document.getElementById('output-text').value = plaintext;
                    updateStatus('Расшифрование успешно', 'success');
                    
                } catch (error) {
                    updateStatus(`Ошибка: ${error.message}`, 'error');
                }
            }
            
            // Сброс настроек
            function reset() {
                currentGrid = JSON.parse(JSON.stringify(defaultGrid));
                renderGrid();
                document.getElementById('transposition-key').value = 'KRYPTOS';
                document.getElementById('input-text').value = 'HELLO';
                document.getElementById('output-text').value = '';
                document.getElementById('debug').innerHTML = '';
                updateStatus('Настройки сброшены', 'success');
            }
            
            // Обновление статуса
            function updateStatus(message, type) {
                const statusElement = document.getElementById('status');
                statusElement.textContent = message;
                statusElement.className = type || '';
            }
            
            // Инициализация
            renderGrid();
            
            // Обработчики событий
            document.getElementById('encrypt-btn').addEventListener('click', encrypt);
            document.getElementById('decrypt-btn').addEventListener('click', decrypt);
            document.getElementById('reset-btn').addEventListener('click', reset);
        });
    </script>
</body>
</html>
