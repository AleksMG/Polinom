<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trifid Cipher Pro | Working Version</title>
    <style>
        :root {
            --bg: #121212;
            --text: #e0e0e0;
            --primary: #1e88e5;
            --secondary: #ff9800;
            --card-bg: #1e1e1e;
            --border: #333;
            --error: #f44336;
            --success: #4caf50;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg);
            color: var(--text);
            margin: 0;
            padding: 20px;
            line-height: 1.6;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px 0;
            border-bottom: 1px solid var(--border);
        }
        h1 {
            font-size: 2.5rem;
            margin: 0;
            color: var(--primary);
        }
        h2 {
            color: var(--secondary);
            margin-top: 0;
        }
        .card {
            background: var(--card-bg);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
        }
        input, textarea, select {
            width: 100%;
            padding: 10px;
            background: #252525;
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            font-size: 16px;
        }
        button {
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 6px;
            padding: 12px 24px;
            cursor: pointer;
            font-weight: 600;
            margin-right: 10px;
        }
        button:disabled {
            background: #555;
            cursor: not-allowed;
        }
        #cube-container {
            width: 100%;
            height: 300px;
            position: relative;
            perspective: 1000px;
            margin: 20px 0;
        }
        #cube {
            width: 200px;
            height: 200px;
            position: absolute;
            transform-style: preserve-3d;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            transition: transform 0.5s;
        }
        .face {
            position: absolute;
            width: 200px;
            height: 200px;
            border: 2px solid #444;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 2px;
            padding: 5px;
            background: rgba(40, 40, 40, 0.9);
        }
        .cell {
            background: #333;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
        .error {
            color: var(--error);
            margin-top: 5px;
        }
        .status {
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
        }
        .success {
            background: var(--success);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>TRIFID CIPHER PRO</h1>
        </header>

        <div class="card">
            <h2>Settings</h2>
            <div class="form-group">
                <label>Alphabet (27 unique characters)</label>
                <input type="text" id="alphabet" value="ABCDEFGHIJKLMNOPQRSTUVWXYZ.">
                <div id="alphabet-error" class="error"></div>
            </div>
            <div class="form-group">
                <label>Encryption Key</label>
                <input type="text" id="key" value="SECRET">
                <div id="key-error" class="error"></div>
            </div>
            <div class="form-group">
                <label>Encryption Rounds</label>
                <select id="rounds">
                    <option value="1">1 Round</option>
                    <option value="3" selected>3 Rounds</option>
                    <option value="5">5 Rounds</option>
                </select>
            </div>
            <button id="init">Initialize Cipher</button>
            <div id="init-status" class="status"></div>
        </div>

        <div class="card">
            <h2>Message Processing</h2>
            <div class="form-group">
                <label>Message</label>
                <textarea id="message">HELLO</textarea>
            </div>
            <button id="encrypt">Encrypt</button>
            <button id="decrypt">Decrypt</button>
            <div id="result" class="status"></div>
        </div>

        <div class="card">
            <h2>3D Cube Visualization</h2>
            <div id="cube-container">
                <div id="cube"></div>
            </div>
            <div id="round-controls"></div>
        </div>
    </div>

    <script>
        class TrifidCipher {
            constructor() {
                this.cubeSize = 3;
                this.rounds = [];
                this.initialized = false;
            }

            async initialize(alphabet, key, roundCount) {
                // Validate inputs
                if (alphabet.length !== 27 || new Set(alphabet).size !== 27) {
                    throw new Error("Alphabet must have exactly 27 unique characters");
                }
                if (!key || key.length < 3) {
                    throw new Error("Key must be at least 3 characters");
                }

                this.rounds = [];
                const baseCube = this.createBaseCube(alphabet);

                // Generate cubes for each round
                for (let i = 0; i < roundCount; i++) {
                    const angles = await this.getRotationAngles(key, i);
                    const rotatedCube = this.rotateCube(baseCube, angles);
                    this.rounds.push({
                        cube: rotatedCube,
                        angles
                    });
                }

                this.initialized = true;
                return this.rounds;
            }

            createBaseCube(alphabet) {
                const cube = [];
                let index = 0;
                for (let z = 0; z < this.cubeSize; z++) {
                    const layer = [];
                    for (let y = 0; y < this.cubeSize; y++) {
                        const row = [];
                        for (let x = 0; x < this.cubeSize; x++) {
                            row.push(alphabet[index++]);
                        }
                        layer.push(row);
                    }
                    cube.push(layer);
                }
                return cube;
            }

            async getRotationAngles(key, round) {
                const hash = await this.sha256(key + round);
                return {
                    x: parseInt(hash.substring(0, 2), 16) % 360,
                    y: parseInt(hash.substring(2, 4), 16) % 360,
                    z: parseInt(hash.substring(4, 6), 16) % 360
                };
            }

            rotateCube(cube, angles) {
                const rotated = this.createEmptyCube();
                const radX = this.toRadians(angles.x);
                const radY = this.toRadians(angles.y);
                const radZ = this.toRadians(angles.z);

                for (let z = 0; z < this.cubeSize; z++) {
                    for (let y = 0; y < this.cubeSize; y++) {
                        for (let x = 0; x < this.cubeSize; x++) {
                            const [nx, ny, nz] = this.rotatePoint(x, y, z, radX, radY, radZ);
                            rotated[nz][ny][nx] = cube[z][y][x];
                        }
                    }
                }
                return rotated;
            }

            rotatePoint(x, y, z, radX, radY, radZ) {
                // Convert to centered coords
                let cx = x - 1;
                let cy = y - 1;
                let cz = z - 1;

                // Apply rotations
                const cosX = Math.cos(radX), sinX = Math.sin(radX);
                const y1 = cy * cosX - cz * sinX;
                const z1 = cy * sinX + cz * cosX;

                const cosY = Math.cos(radY), sinY = Math.sin(radY);
                const x2 = cx * cosY + z1 * sinY;
                const z2 = -cx * sinY + z1 * cosY;

                const cosZ = Math.cos(radZ), sinZ = Math.sin(radZ);
                const x3 = x2 * cosZ - y1 * sinZ;
                const y3 = x2 * sinZ + y1 * cosZ;

                // Convert back and clamp
                return [
                    Math.max(0, Math.min(2, Math.round(x3 + 1))),
                    Math.max(0, Math.min(2, Math.round(y3 + 1))),
                    Math.max(0, Math.min(2, Math.round(z2 + 1)))
                ];
            }

            async sha256(message) {
                const encoder = new TextEncoder();
                const data = encoder.encode(message);
                const hashBuffer = await crypto.subtle.digest('SHA-256', data);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            }

            toRadians(degrees) {
                return degrees * Math.PI / 180;
            }

            createEmptyCube() {
                return Array(this.cubeSize).fill().map(() => 
                    Array(this.cubeSize).fill().map(() => 
                        Array(this.cubeSize).fill(null)
                    )
                );
            }

            async encrypt(message) {
                if (!this.initialized) throw new Error("Cipher not initialized");
                
                let result = '';
                for (let i = 0; i < message.length; i++) {
                    const char = message[i].toUpperCase();
                    if (char === ' ') {
                        result += ' ';
                        continue;
                    }

                    const round = i % this.rounds.length;
                    const cube = this.rounds[round].cube;
                    const coords = this.findInCube(char, cube);
                    result += coords || '000';
                }
                return result;
            }

            async decrypt(ciphertext) {
                if (!this.initialized) throw new Error("Cipher not initialized");
                
                let result = '';
                const coordRegex = /(\d)(\d)(\d)|(\s)/g;
                let match;
                let i = 0;
                
                while ((match = coordRegex.exec(ciphertext)) !== null) {
                    if (match[4]) {
                        result += ' ';
                        continue;
                    }

                    const round = i % this.rounds.length;
                    const cube = this.rounds[round].cube;
                    const x = parseInt(match[1]);
                    const y = parseInt(match[2]);
                    const z = parseInt(match[3]);
                    
                    if (x < 3 && y < 3 && z < 3) {
                        result += cube[z][y][x];
                    } else {
                        result += '?';
                    }
                    i++;
                }
                return result;
            }

            findInCube(char, cube) {
                for (let z = 0; z < this.cubeSize; z++) {
                    for (let y = 0; y < this.cubeSize; y++) {
                        for (let x = 0; x < this.cubeSize; x++) {
                            if (cube[z][y][x] === char) return `${x}${y}${z}`;
                        }
                    }
                }
                return null;
            }
        }

        class CubeVisualizer {
            constructor(containerId) {
                this.container = document.getElementById(containerId);
                this.cube = document.getElementById('cube');
                this.faces = [];
                this.createFaces();
            }

            createFaces() {
                const positions = [
                    { name: 'front', transform: 'rotateY(0deg) translateZ(100px)' },
                    { name: 'back', transform: 'rotateY(180deg) translateZ(100px)' },
                    { name: 'right', transform: 'rotateY(90deg) translateZ(100px)' },
                    { name: 'left', transform: 'rotateY(-90deg) translateZ(100px)' },
                    { name: 'top', transform: 'rotateX(90deg) translateZ(100px)' },
                    { name: 'bottom', transform: 'rotateX(-90deg) translateZ(100px)' }
                ];

                positions.forEach(pos => {
                    const face = document.createElement('div');
                    face.className = `face ${pos.name}`;
                    face.style.transform = pos.transform;
                    
                    for (let i = 0; i < 9; i++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        face.appendChild(cell);
                    }
                    
                    this.faces.push(face);
                    this.cube.appendChild(face);
                });
            }

            updateCube(cubeData) {
                // Update front face (z=0)
                this.updateFace(0, cubeData[0]);
                // Update back face (z=2)
                this.updateFace(1, cubeData[2]);
                // Update right face (x=2)
                this.updateFace(2, cubeData.map(layer => layer.map(row => row[2])));
                // Update left face (x=0)
                this.updateFace(3, cubeData.map(layer => layer.map(row => row[0])));
                // Update top face (y=0)
                this.updateFace(4, cubeData.map(layer => layer[0]));
                // Update bottom face (y=2)
                this.updateFace(5, cubeData.map(layer => layer[2]));
            }

            updateFace(faceIndex, faceData) {
                const cells = this.faces[faceIndex].querySelectorAll('.cell');
                let index = 0;
                
                for (let y = 0; y < 3; y++) {
                    for (let x = 0; x < 3; x++) {
                        cells[index].textContent = faceData[y][x];
                        index++;
                    }
                }
            }

            updateTransform(angles) {
                this.cube.style.transform = `translate(-50%, -50%) rotateX(${angles.x}deg) rotateY(${angles.y}deg) rotateZ(${angles.z}deg)`;
            }
        }

        // Main application
        document.addEventListener('DOMContentLoaded', () => {
            const cipher = new TrifidCipher();
            const visualizer = new CubeVisualizer('cube-container');
            
            // DOM elements
            const alphabetInput = document.getElementById('alphabet');
            const keyInput = document.getElementById('key');
            const roundsSelect = document.getElementById('rounds');
            const initBtn = document.getElementById('init');
            const initStatus = document.getElementById('init-status');
            const messageInput = document.getElementById('message');
            const encryptBtn = document.getElementById('encrypt');
            const decryptBtn = document.getElementById('decrypt');
            const resultDiv = document.getElementById('result');
            const roundControls = document.getElementById('round-controls');

            // Initialize cipher
            initBtn.addEventListener('click', async () => {
                try {
                    const rounds = await cipher.initialize(
                        alphabetInput.value,
                        keyInput.value,
                        parseInt(roundsSelect.value)
                    );
                    
                    // Update UI
                    initStatus.textContent = `Cipher initialized with ${rounds.length} rounds`;
                    initStatus.className = 'status success';
                    encryptBtn.disabled = false;
                    decryptBtn.disabled = false;
                    
                    // Create round controls
                    roundControls.innerHTML = '';
                    rounds.forEach((round, i) => {
                        const btn = document.createElement('button');
                        btn.textContent = `Round ${i+1}`;
                        btn.addEventListener('click', () => {
                            visualizer.updateCube(round.cube);
                            visualizer.updateTransform(round.angles);
                        });
                        roundControls.appendChild(btn);
                    });
                    
                    // Show first round
                    visualizer.updateCube(rounds[0].cube);
                    visualizer.updateTransform(rounds[0].angles);
                    
                } catch (e) {
                    initStatus.textContent = `Error: ${e.message}`;
                    initStatus.className = 'status error';
                }
            });

            // Encrypt handler
            encryptBtn.addEventListener('click', async () => {
                try {
                    const encrypted = await cipher.encrypt(messageInput.value);
                    resultDiv.textContent = encrypted;
                    resultDiv.className = 'status success';
                } catch (e) {
                    resultDiv.textContent = `Error: ${e.message}`;
                    resultDiv.className = 'status error';
                }
            });

            // Decrypt handler
            decryptBtn.addEventListener('click', async () => {
                try {
                    const decrypted = await cipher.decrypt(messageInput.value);
                    resultDiv.textContent = decrypted;
                    resultDiv.className = 'status success';
                } catch (e) {
                    resultDiv.textContent = `Error: ${e.message}`;
                    resultDiv.className = 'status error';
                }
            });

            // Initial state
            encryptBtn.disabled = true;
            decryptBtn.disabled = true;
        });
    </script>
</body>
</html>
