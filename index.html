<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PolyCipher Pro - Secure Block Encryption</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary: #2563eb;
            --secondary: #1e40af;
            --dark: #0f172a;
            --darker: #020617;
            --light: #f8fafc;
            --danger: #dc2626;
            --success: #10b981;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: var(--dark);
            color: var(--light);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        header {
            background: var(--darker);
            padding: 1.5rem;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .header-content {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .logo-icon {
            color: var(--primary);
            font-size: 1.8rem;
        }

        .logo-text {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--light);
        }

        .security-badge {
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.9rem;
        }

        main {
            flex: 1;
            padding: 2rem;
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
        }

        .card {
            background: rgba(15, 23, 42, 0.8);
            border-radius: 12px;
            padding: 2rem;
            margin-bottom: 2rem;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
        }

        .card-title {
            font-size: 1.3rem;
            margin-bottom: 1.5rem;
            color: var(--primary);
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .form-group {
            margin-bottom: 1.5rem;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            color: var(--light);
            opacity: 0.9;
            font-size: 0.95rem;
        }

        input, textarea, select {
            width: 100%;
            padding: 0.875rem;
            background: rgba(2, 6, 23, 0.8);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            color: var(--light);
            font-size: 1rem;
            transition: all 0.2s;
        }

        input:focus, textarea:focus, select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.3);
        }

        .btn {
            padding: 0.875rem 1.75rem;
            border-radius: 8px;
            border: none;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.95rem;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-primary:hover {
            background: var(--secondary);
            transform: translateY(-1px);
        }

        .btn-success {
            background: var(--success);
            color: white;
        }

        .btn-group {
            display: flex;
            gap: 1rem;
            margin-top: 1.5rem;
            flex-wrap: wrap;
        }

        .result-container {
            margin-top: 2rem;
        }

        .result-text {
            background: rgba(2, 6, 23, 0.8);
            padding: 1.5rem;
            border-radius: 8px;
            font-family: monospace;
            font-size: 1rem;
            min-height: 120px;
            overflow-x: auto;
            border: 1px dashed var(--primary);
            white-space: pre-wrap;
            word-break: break-all;
        }

        .error-message {
            color: var(--danger);
            font-size: 0.9rem;
            margin-top: 0.5rem;
            display: none;
        }

        .loading {
            display: none;
            color: var(--success);
            font-size: 0.9rem;
            margin-top: 0.5rem;
        }

        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }

        @media (max-width: 768px) {
            .btn-group {
                flex-direction: column;
            }
            
            .btn {
                width: 100%;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="header-content">
            <div class="logo">
                <div class="logo-icon"><i class="fas fa-lock"></i></div>
                <div class="logo-text">PolyCipher Pro</div>
            </div>
            <div class="security-badge">
                <i class="fas fa-shield-alt"></i> BLOCK CIPHER MODE
            </div>
        </div>
    </header>

    <main>
        <div class="card">
            <h2 class="card-title"><i class="fas fa-cog"></i> Cipher Configuration</h2>
            
            <div class="form-group">
                <label for="alphabet"><i class="fas fa-font"></i> Alphabet</label>
                <input type="text" id="alphabet" value="ABCDEFGHIJKLMNOPQRSTUVWXYZ" maxlength="256">
                <div id="alphabet-error" class="error-message"></div>
            </div>
            
            <div class="form-group">
                <label for="symbols"><i class="fas fa-symbols"></i> Symbol Mapping (must match alphabet length)</label>
                <input type="text" id="symbols" value="ⴰⴱⴲⴳⴴⴵⴶⴷⴸⴹⴺⴻⴼⴽⴾⴿⵀⵁⵂⵃⵄⵅⵆⵇⵈ" maxlength="256">
                <div id="symbols-error" class="error-message"></div>
            </div>
            
            <div class="form-group">
                <label for="key"><i class="fas fa-key"></i> Encryption Key</label>
                <input type="password" id="key" value="SecureKey123!" placeholder="Enter a strong encryption key">
                <div id="key-error" class="error-message"></div>
            </div>
            
            <div class="form-group">
                <label for="blockSize"><i class="fas fa-cube"></i> Block Size (characters)</label>
                <select id="blockSize">
                    <option value="8">8 (Fast)</option>
                    <option value="16" selected>16 (Recommended)</option>
                    <option value="32">32 (Maximum)</option>
                </select>
            </div>
        </div>

        <div class="card">
            <h2 class="card-title"><i class="fas fa-edit"></i> Text Input</h2>
            <div class="form-group">
                <label for="inputText"><i class="fas fa-keyboard"></i> Input Text</label>
                <textarea id="inputText" rows="5">HELLO WORLD</textarea>
            </div>
            
            <div class="btn-group">
                <button class="btn btn-primary" id="encryptBtn">
                    <i class="fas fa-lock"></i> Encrypt
                </button>
                <button class="btn btn-success" id="decryptBtn">
                    <i class="fas fa-lock-open"></i> Decrypt
                </button>
                <button class="btn btn-primary" id="resetBtn">
                    <i class="fas fa-redo"></i> Reset
                </button>
            </div>
            <div id="loading" class="loading">
                <i class="fas fa-spinner fa-spin"></i> Processing...
            </div>
        </div>

        <div class="card result-container">
            <h2 class="card-title"><i class="fas fa-terminal"></i> Result</h2>
            <div class="result-text" id="outputText">
                Encrypted/decrypted text will appear here...
            </div>
        </div>
    </main>

    <footer>
        <div>PolyCipher Pro v3.1 | Secure Block Cipher System</div>
    </footer>

    <script>
        class PolyCipher {
            constructor() {
                this.encoder = new TextEncoder();
                this.decoder = new TextDecoder();
            }

            async deriveKeys(password, salt, iterations = 100000) {
                try {
                    const keyMaterial = await crypto.subtle.importKey(
                        'raw',
                        this.encoder.encode(password),
                        { name: 'PBKDF2' },
                        false,
                        ['deriveBits']
                    );
                    
                    const derivedBits = await crypto.subtle.deriveBits(
                        {
                            name: 'PBKDF2',
                            salt: this.encoder.encode(salt),
                            iterations,
                            hash: 'SHA-256'
                        },
                        keyMaterial,
                        256
                    );
                    
                    return arrayToHex(new Uint8Array(derivedBits));
                } catch (error) {
                    console.error("Key derivation failed:", error);
                    throw new Error("Key derivation failed");
                }
            }

            async encrypt(plaintext, alphabet, symbols, password, blockSize = 16) {
                if (!this.validateInputs(alphabet, symbols, password)) {
                    throw new Error("Invalid inputs");
                }

                // Generate random salt for this encryption
                const salt = this.generateRandomString(32);
                const derivedKey = await this.deriveKeys(password, salt);
                
                // Process in blocks
                let ciphertext = '';
                const blocks = this.splitIntoBlocks(plaintext, blockSize);
                
                for (let i = 0; i < blocks.length; i++) {
                    const block = blocks[i];
                    const encryptedBlock = await this.processBlock(
                        block, 
                        alphabet, 
                        symbols, 
                        derivedKey + i.toString()
                    );
                    ciphertext += encryptedBlock;
                }
                
                return { ciphertext, salt };
            }

            async decrypt(ciphertext, alphabet, symbols, password, salt, blockSize = 16) {
                if (!this.validateInputs(alphabet, symbols, password)) {
                    throw new Error("Invalid inputs");
                }

                const derivedKey = await this.deriveKeys(password, salt);
                let plaintext = '';
                const blocks = this.splitIntoBlocks(ciphertext, blockSize);
                
                for (let i = 0; i < blocks.length; i++) {
                    const block = blocks[i];
                    const decryptedBlock = await this.processBlock(
                        block, 
                        symbols, 
                        alphabet, 
                        derivedKey + i.toString(),
                        true
                    );
                    plaintext += decryptedBlock;
                }
                
                return plaintext;
            }

            async processBlock(block, sourceAlphabet, targetAlphabet, key, isDecrypt = false) {
                // Generate polynomial coefficients from key
                const coeffs = await this.generateCoefficients(key, 3);
                
                let result = '';
                for (let i = 0; i < block.length; i++) {
                    const char = block[i];
                    const index = sourceAlphabet.indexOf(char);
                    
                    if (index === -1) {
                        result += char;
                        continue;
                    }
                    
                    // Non-linear transformation with position-dependent factor
                    const positionFactor = (i % 7) + 1;
                    const x = (index * positionFactor) % sourceAlphabet.length;
                    
                    const transformedIndex = this.polynomialTransform(
                        x, 
                        coeffs, 
                        sourceAlphabet.length
                    ) % targetAlphabet.length;
                    
                    result += targetAlphabet[transformedIndex];
                }
                
                return result;
            }

            async generateCoefficients(key, degree) {
                const hash = await crypto.subtle.digest(
                    'SHA-256', 
                    this.encoder.encode(key)
                );
                
                const view = new DataView(hash);
                const coeffs = [];
                
                for (let i = 0; i <= degree; i++) {
                    coeffs.push(view.getUint32(i * 4) % 65537);
                }
                
                return coeffs;
            }

            polynomialTransform(x, coeffs, mod) {
                let result = 0;
                for (let i = 0; i < coeffs.length; i++) {
                    const exponent = coeffs.length - 1 - i;
                    const term = this.modPow(x, exponent, mod);
                    result = (result + coeffs[i] * term) % mod;
                }
                return result;
            }

            modPow(base, exponent, modulus) {
                if (modulus === 1) return 0;
                let result = 1;
                base = base % modulus;
                
                while (exponent > 0) {
                    if (exponent % 2 === 1) {
                        result = (result * base) % modulus;
                    }
                    exponent = exponent >> 1;
                    base = (base * base) % modulus;
                }
                return result;
            }

            splitIntoBlocks(text, blockSize) {
                const blocks = [];
                for (let i = 0; i < text.length; i += blockSize) {
                    blocks.push(text.substr(i, blockSize));
                }
                return blocks;
            }

            generateRandomString(length) {
                const array = new Uint8Array(length);
                crypto.getRandomValues(array);
                return Array.from(array, byte => 
                    byte.toString(16).padStart(2, '0')).join('');
            }

            validateInputs(alphabet, symbols, password) {
                if (alphabet.length !== symbols.length) {
                    alert("Alphabet and symbols must be the same length");
                    return false;
                }
                if (password.length < 8) {
                    alert("Password must be at least 8 characters");
                    return false;
                }
                return true;
            }
        }

        // Helper function
        function arrayToHex(buffer) {
            return Array.from(new Uint8Array(buffer))
                .map(b => b.toString(16).padStart(2, '0'))
                .join('');
        }

        // UI Handling
        document.addEventListener('DOMContentLoaded', function() {
            const cipher = new PolyCipher();
            let currentSalt = '';
            
            // Event listeners
            document.getElementById('encryptBtn').addEventListener('click', async () => {
                try {
                    showLoading(true);
                    const alphabet = document.getElementById('alphabet').value;
                    const symbols = document.getElementById('symbols').value;
                    const key = document.getElementById('key').value;
                    const text = document.getElementById('inputText').value;
                    const blockSize = parseInt(document.getElementById('blockSize').value);
                    
                    const { ciphertext, salt } = await cipher.encrypt(
                        text, 
                        alphabet, 
                        symbols, 
                        key, 
                        blockSize
                    );
                    
                    currentSalt = salt;
                    document.getElementById('outputText').textContent = ciphertext;
                } catch (error) {
                    console.error("Encryption failed:", error);
                    document.getElementById('outputText').textContent = `Error: ${error.message}`;
                } finally {
                    showLoading(false);
                }
            });
            
            document.getElementById('decryptBtn').addEventListener('click', async () => {
                try {
                    showLoading(true);
                    const alphabet = document.getElementById('alphabet').value;
                    const symbols = document.getElementById('symbols').value;
                    const key = document.getElementById('key').value;
                    const text = document.getElementById('inputText').value;
                    const blockSize = parseInt(document.getElementById('blockSize').value);
                    
                    if (!currentSalt) {
                        throw new Error("No salt found - encrypt first or reset");
                    }
                    
                    const plaintext = await cipher.decrypt(
                        text, 
                        alphabet, 
                        symbols, 
                        key, 
                        currentSalt, 
                        blockSize
                    );
                    
                    document.getElementById('outputText').textContent = plaintext;
                } catch (error) {
                    console.error("Decryption failed:", error);
                    document.getElementById('outputText').textContent = `Error: ${error.message}`;
                } finally {
                    showLoading(false);
                }
            });
            
            document.getElementById('resetBtn').addEventListener('click', () => {
                document.getElementById('inputText').value = "HELLO WORLD";
                document.getElementById('outputText').textContent = "Encrypted/decrypted text will appear here...";
                currentSalt = '';
            });
            
            function showLoading(show) {
                document.getElementById('loading').style.display = show ? 'block' : 'none';
            }
        });
    </script>
</body>
</html>
